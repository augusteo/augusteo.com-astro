---
import { getCollection } from "astro:content";

// Get all tags and count occurrences
const posts = await getCollection("blog", ({ data }) => !data.draft);
const tagCounts = new Map<string, number>();
posts.forEach(post => {
  const primaryTag = post.data.tags[0].toLowerCase();
  tagCounts.set(primaryTag, (tagCounts.get(primaryTag) || 0) + 1);
});

// Sort by count descending
const sortedTags = [...tagCounts.entries()].sort((a, b) => b[1] - a[1]);
---

<div class="blog-filters">
  <div class="search-wrapper">
    <input
      type="text"
      class="search-input"
      placeholder="Search posts..."
    />
  </div>
  <div class="filters">
    <button class="filter-btn active" data-tag="all">All ({posts.length})</button>
    {sortedTags.map(([tag, count]) => (
      <button class="filter-btn" data-tag={tag}>
        {tag.charAt(0).toUpperCase() + tag.slice(1)} ({count})
      </button>
    ))}
  </div>
</div>

<script>
  function initTagFilter() {
    let searchInput = document.querySelector(".search-input") as HTMLInputElement;
    const filterBtns = document.querySelectorAll(".filter-btn");
    const postCards = document.querySelectorAll(".post-card");

    if (!searchInput || filterBtns.length === 0) return;

    // Restore state from sessionStorage
    let activeTag = sessionStorage.getItem("blogTag") || "all";
    const savedSearch = sessionStorage.getItem("blogSearch") || "";

    // Remove existing listeners before adding new ones (prevents duplicates after navigation)
    const newSearchInput = searchInput.cloneNode(true) as HTMLInputElement;
    searchInput.parentNode?.replaceChild(newSearchInput, searchInput);
    searchInput = newSearchInput;

    // Apply saved state
    searchInput.value = savedSearch;
    filterBtns.forEach((btn) => {
      const tag = (btn as HTMLElement).dataset.tag;
      btn.classList.toggle("active", tag === activeTag);
    });

    function filterPosts() {
      const query = searchInput.value.toLowerCase().trim();
      sessionStorage.setItem("blogSearch", query);

      postCards.forEach((card) => {
        const cardEl = card as HTMLElement;
        const cardTag = cardEl.dataset.tag || "";
        const matchesTag = activeTag === "all" || cardTag === activeTag;

        let matchesSearch = true;
        if (query) {
          const title = cardEl.dataset.title || "";
          const description = cardEl.dataset.description || "";
          const slug = cardEl.dataset.slug || "";
          const tags = cardEl.dataset.tags || "";
          matchesSearch = title.includes(query) || description.includes(query) || slug.includes(query) || tags.includes(query);
        }

        if (matchesTag && matchesSearch) {
          cardEl.style.display = "grid";
        } else {
          cardEl.style.display = "none";
        }
      });
    }

    searchInput.addEventListener("input", filterPosts);

    filterBtns.forEach((btn) => {
      const newBtn = btn.cloneNode(true);
      btn.parentNode?.replaceChild(newBtn, btn);
      newBtn.addEventListener("click", () => {
        activeTag = (newBtn as HTMLElement).dataset.tag || "all";
        sessionStorage.setItem("blogTag", activeTag);

        document.querySelectorAll(".filter-btn").forEach((b) => b.classList.remove("active"));
        newBtn.classList.add("active");

        filterPosts();
      });
    });

    // Apply initial filter
    filterPosts();
  }

  // Run on initial load
  initTagFilter();

  // Re-run after View Transitions navigation
  document.addEventListener("astro:after-swap", initTagFilter);
</script>

<style>
  .blog-filters {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .search-wrapper {
    position: relative;
    max-width: 300px;
    padding: 8px;
  }

  .search-wrapper::before {
    content: "";
    position: absolute;
    inset: 0;
    background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 40' preserveAspectRatio='none'%3E%3Cdefs%3E%3Cfilter id='searchBorder'%3E%3CfeTurbulence baseFrequency='0.03' numOctaves='2'/%3E%3CfeDisplacementMap in='SourceGraphic' scale='4'/%3E%3C/filter%3E%3C/defs%3E%3Cpath d='M8,8 Q4,4 30,6 T100,5 T170,6 T192,8 Q196,12 194,20 T196,32 Q192,36 170,34 T100,35 T30,34 T8,32 Q4,28 6,20 T4,12 Z' stroke='%23b2bec3' stroke-width='1.5' fill='none' filter='url(%23searchBorder)'/%3E%3C/svg%3E");
    background-size: 100% 100%;
    pointer-events: none;
    opacity: 0.8;
    transition: opacity 0.2s;
  }

  .search-wrapper:focus-within::before {
    opacity: 1;
    background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 40' preserveAspectRatio='none'%3E%3Cdefs%3E%3Cfilter id='searchBorderFocus'%3E%3CfeTurbulence baseFrequency='0.03' numOctaves='2'/%3E%3CfeDisplacementMap in='SourceGraphic' scale='4'/%3E%3C/filter%3E%3C/defs%3E%3Cpath d='M8,8 Q4,4 30,6 T100,5 T170,6 T192,8 Q196,12 194,20 T196,32 Q192,36 170,34 T100,35 T30,34 T8,32 Q4,28 6,20 T4,12 Z' stroke='%234682b4' stroke-width='1.5' fill='none' filter='url(%23searchBorderFocus)'/%3E%3C/svg%3E");
    background-size: 100% 100%;
  }

  .search-input {
    font-family: var(--font-hand);
    font-size: 1.1rem;
    padding: 0.4rem 0.5rem;
    background: transparent;
    border: none;
    color: var(--color-ink);
    width: 100%;
  }

  .search-input::placeholder {
    color: var(--color-ink-light);
    opacity: 0.7;
  }

  .search-input:focus {
    outline: none;
  }

  .filters {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    margin-bottom: 2rem;
  }

  .filter-btn {
    font-family: var(--font-hand);
    font-size: 1.1rem;
    padding: 0.4rem 1rem;
    background: transparent;
    border: none;
    color: var(--color-ink-light);
    cursor: pointer;
    position: relative;
    transition: color 0.2s;
  }

  .filter-btn::before {
    content: "";
    position: absolute;
    inset: 0;
    background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 80 40'%3E%3Cdefs%3E%3Cfilter id='filterTag'%3E%3CfeTurbulence baseFrequency='0.04'/%3E%3CfeDisplacementMap in='SourceGraphic' scale='5'/%3E%3C/filter%3E%3C/defs%3E%3Cellipse cx='40' cy='20' rx='38' ry='18' fill='%2387ceeb' opacity='0.4' filter='url(%23filterTag)'/%3E%3C/svg%3E");
    background-size: 100% 100%;
    opacity: 0;
    transition: opacity 0.2s;
    z-index: -1;
  }

  .filter-btn:hover::before,
  .filter-btn.active::before {
    opacity: 1;
  }

  .filter-btn.active {
    color: var(--color-ink);
  }
</style>
